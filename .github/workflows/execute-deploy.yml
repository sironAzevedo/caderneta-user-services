name: user-service

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      github_environment:
        required: false
        type: string
    secrets:
      docker-user:
        required: true
      docker-pass:
        required: true
      docker-repo:
        required: true
      github-token:
        required: true
      vps-host:
        required: true
      vps-username:
        required: true
      vps-ssh-private-key:
        required: true
      APP_SECRETS:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  build_and_publish:
    name: Build, Package and Publish
    runs-on: ubuntu-latest
    outputs:
      APP_VERSION: ${{ steps.versioning.outputs.APP_VERSION }}
      JSON_B64: ${{ steps.replace_secrets.outputs.JSON_B64 }}
      APP_NAME: ${{ steps.json_config.outputs.APP_NAME }}
      APP_PORT: ${{ steps.json_config.outputs.APP_PORT }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: 17

      - name: Read config.json for the selected environment
        id: json_config
        run: |
          ENV_NAME=${{ inputs.environment }}
          echo "Reading configuration for environment: $ENV_NAME"
          
          CONFIG_PATH="infra/$ENV_NAME/config.json"
          
          sudo apt-get update && sudo apt-get install -y jq
          APP_NAME=$(jq -r '.nameAPP' "$CONFIG_PATH")
          APP_PORT=$(jq -r '.port' "$CONFIG_PATH")
          
          echo "APP_NAME=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "APP_PORT=${APP_PORT}" >> $GITHUB_OUTPUT
          
          echo "Application name: $APP_NAME"
          echo "Application port: $APP_PORT"

      - name: Replace Secrets in JSON Config
        id: replace_secrets
        env:
          APP_SECRETS: ${{ secrets.APP_SECRETS }}
          ENV_NAME: ${{ inputs.environment }}
        run: |
          CONFIG_PATH="infra/$ENV_NAME/config.json"
          JSON_CONFIG=$(cat "$CONFIG_PATH")
          
          echo "Replacing SECRET:: placeholders..."
          RESOLVED_JSON=$(echo "$JSON_CONFIG" | jq -c --argjson secrets "$APP_SECRETS" \
            ' .environment |= map(
                if .value | startswith("SECRET::") then
                  .value = ($secrets[.value[8:]] // "SECRET_NOT_FOUND")
                else
                  .
                end
              )')
          
          # Validar o resultado
          echo "$RESOLVED_JSON" | jq . >/dev/null || { echo "‚ùå JSON inv√°lido ap√≥s replace"; exit 1; }
          echo "‚úÖ JSON v√°lido ap√≥s replace"

          # Converte para Base64 para transportar sem quebra de formato
          JSON_B64=$(echo "$RESOLVED_JSON" | base64 -w0 2>/dev/null || echo "$RESOLVED_JSON" | base64)
          echo "JSON_B64=$JSON_B64" >> $GITHUB_OUTPUT

      - name: Set and Update Application Version
        id: versioning
        run: |
          NEW_VERSION="1.0.${{ github.run_number }}"
          echo "Nova vers√£o da aplica√ß√£o: $NEW_VERSION"
          mvn versions:set -DnewVersion=$NEW_VERSION
          echo "APP_VERSION=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Configure Maven settings
        run: |
          mkdir -p ~/.m2
          echo "<settings><servers><server><id>github</id><username>\${env.GITHUB_ACTOR}</username><password>\${env.GITHUB_TOKEN}</password></server></servers></settings>" > ~/.m2/settings.xml
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Package with Maven
        run: mvn clean package -DskipTests
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Verify JAR file
        run: |
          echo "JAR file created:"
          ls -la target/*.jar
          echo "File size: $(du -h target/*.jar | cut -f1)"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.docker-user }}
          password: ${{ secrets.docker-pass }}

      - name: Build and push multi-arch image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:${{ steps.versioning.outputs.APP_VERSION }}
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:latest

  deploy:
    name: Deploy da aplica√ß√£o
    runs-on: ubuntu-latest
    needs: [ build_and_publish ]
    steps:
      - name: Execute deploy
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.vps-host }}
          username: ${{ secrets.vps-username }}
          key: ${{ secrets.vps-ssh-private-key }}
          script: |
            set -euo pipefail
            
            APP_VERSION="${{ needs.build_and_publish.outputs.APP_VERSION }}"
            JSON_B64='${{ needs.build_and_publish.outputs.JSON_B64 }}'
            APP_NAME="${{ needs.build_and_publish.outputs.APP_NAME }}"
            APP_PORT="${{ needs.build_and_publish.outputs.APP_PORT }}"
            REPO_DOCKER="${{ secrets.docker-repo }}"
            IMAGE_NAME="$REPO_DOCKER/$APP_NAME:$APP_VERSION"
            
            echo "üöÄ Iniciando o deploy da vers√£o: $APP_VERSION para a aplica√ß√£o: $APP_NAME"
            
            if ! command -v jq &> /dev/null; then
                echo "jq n√£o encontrado. Instalando..."
                sudo apt-get update && sudo apt-get install -y jq
            fi
            
            # Decodifica JSON
            JSON_CONFIG=$(echo "$JSON_B64" | base64 -d)
            
            # Extrai configs com fallback
            CPUS=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .cpus // "1.0"')
            MEMORY=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memory // "800m"')
            MEMORY_SWAP=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memorySwap // "1G"')
            
            echo "‚úÖ Config extra√≠da:"
            echo "   CPUs: $CPUS"
            echo "   Memory: $MEMORY"
            echo "   Memory Swap: $MEMORY_SWAP"
            
            echo "üìÑ Criar arquivo .env tempor√°rio"
            TMP_DIR=$(mktemp -d)
            ENV_FILE="$TMP_DIR/$APP_NAME/${{ github.run_number }}/.env"
            mkdir -p $(dirname "$ENV_FILE")
            
            echo "$JSON_CONFIG" | jq -r '.environment[] | "\(.name)=\(.value)"' > "$ENV_FILE"
            
            echo "Conte√∫do do arquivo .env:"
            awk -F= '{print $1 "=***"}' "$ENV_FILE"
            
            echo "‚¨áÔ∏è Pull da nova imagem: $IMAGE_NAME"
            docker pull "$IMAGE_NAME"
            
            echo "üöÄ Parar e remover cont√™iner antigo (se existir)"
            if [ "$(docker ps -q -f name=^/${APP_NAME}$)" ]; then
                docker stop "$APP_NAME"
                docker rm "$APP_NAME"
            fi
            
            echo "üóëÔ∏è Removendo imagens antigas..."
            OLD_IMAGES=$(docker images -q $REPO_DOCKER/$APP_NAME)
            [ -n "$OLD_IMAGES" ] && docker rmi -f $OLD_IMAGES || true
            
            echo "Iniciando novo cont√™iner..."
            docker run -d \
              -p "${APP_PORT}:8080" \
              --name "$APP_NAME" \
              --network app-network \
              --restart always \
              --cpus="$CPUS" \
              --memory="$MEMORY" \
              --memory-swap="$MEMORY_SWAP" \
              --env-file "$ENV_FILE" \
              "$IMAGE_NAME"
            
            rm -rf "$TMP_DIR"
            
            echo "‚è≥ Aguardando aplica√ß√£o subir..."
            sleep 20
            
            echo "ü©∫ Health Check..."
            for i in {1..12}; do
              HEALTH_STATUS=$(curl -s http://localhost:${APP_PORT}/actuator/health || true)
              if echo "$HEALTH_STATUS" | grep -q '{"status":"UP"}'; then
                echo "‚úÖ Aplica√ß√£o est√° UP e saud√°vel!"
                exit 0
              fi
              echo "‚ö™Ô∏è Tentativa $i/12: n√£o est√° pronta ainda ($HEALTH_STATUS)"
              sleep 5
            done
            
            echo "‚ùå Aplica√ß√£o n√£o subiu, rollback necess√°rio"            
            exit 1
